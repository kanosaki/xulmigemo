#include "nsISupports.idl"
#include "nsIObserver.idl"
#include "nsIFile.idl"
#include "nsIDOMWindow.idl"
#include "nsIDOMDocument.idl"
#include "nsIDOMRange.idl"
#include "nsIDOMNode.idl"

[scriptable, uuid(181378ba-ce43-11db-8314-0800200c9a66)]
interface pIXMigemo : nsIObserver
{
	/* create regular expressions from roman letters. */
	AString getRegExp(in AString roman);

	/* get entries of words in the dictionary. */
	void gatherEntriesFor(
		in AString roman,
		in unsigned short targetDictionaryType,
		out unsigned long count, [array, size_is(count), retval] out wstring array
	);
	const unsigned short SYSTEM_DIC = 1;
	const unsigned short USER_DIC   = 2;
	const unsigned short ALL_DIC    = 3; /* SYSTEM_DIC + USER_DIC */

	/* find by regular expression, and return the first item of found terms as DOM2 Range. */
	nsIDOMRange regExpFind(
		in AString regExpSource,
		in AString regExpFlags,
		in nsIDOMRange findRange,
		in nsIDOMRange startPoint,
		in nsIDOMRange endPoint,
		in boolean findBackwards
	);
	/* this returns all of found terms as an array. */
	void regExpFindArr(
		in AString regExpSource,
		in AString regExpFlags,
		in nsIDOMRange findRange,
		in nsIDOMRange startPoint,
		in nsIDOMRange endPoint,
		out unsigned long count, [array, size_is(count), retval] out nsIDOMRange array
	);

	attribute double createCacheTimeOverride;
};

[scriptable, uuid(54606802-ce50-11db-8314-0800200c9a66)]
interface pIXMigemoFind : nsIObserver
{
	/* target node; <xul:browser/>, <xul:tabbrowser/> or <xul:iframe/> */
	attribute nsIDOMNode target;

	attribute boolean manualLinksOnly;
	attribute boolean isQuickFind;

	readonly attribute AString lastKeyword;
	readonly attribute AString previousKeyword;
	readonly attribute AString lastFoundWord;

	AString appendKeyword(in AString character);
	AString replaceKeyword(in AString keyword);
	AString removeKeyword(in double length);
	void shiftLastKeyword();

	void find(in boolean backward, in AString keyword, in boolean forceFocus);
	void findNext(in boolean forceFocus);
	void findPrevious(in boolean forceFocus);

	void setSelectionLook(in nsIDOMDocument document, in boolean changeColor);

	void scrollSelectionToCenter(in nsIDOMWindow frame);

	void clear();
	void exitFind();
};




[scriptable, uuid(4341d5c8-cde6-11db-8314-0800200c9a66)]
interface pIXMigemoFileAccess : nsISupports
{
	AString readFrom(in nsIFile file, in ACString encoding);
	nsIFile writeTo(in nsIFile file, in AString content, in ACString encoding);
};


[scriptable, uuid(749f4faa-cdf6-11db-8314-0800200c9a66)]
interface pIXMigemoTextTransform : nsISupports
{
	AString range2Text(in nsIDOMRange range);

	AString hira2kana(in AString hiragana);
	AString zenkaku2hankaku(in AString zenkaku);
	AString roman2zen(in AString roman);
	AString katakanav(in AString katakana);

	AString normalizeForYomi(in AString yomigana);
	boolean isYomi(in AString yomigana);

	AString joinVoiceMarks(in AString hiragana);
	AString kana2hira(in AString katakana);
	AString hira2roman(in AString hiragana);

	AString sanitize(in AString regexpPattern);
	AString sanitize2(in AString regexpPattern);
	AString reverseRegExp(in AString regexpPattern);

	AString convertStr(in AString roman);
	AString convertStr2(in AString roman, in unsigned short kanaFlag);
	AString toZen(in AString romanChar, in AString lastChar, in AString last2Char, in unsigned short kanaFlag);
	AString getKana(in AString key, in unsigned short kanaFlag);
	const unsigned short KANA_HIRA = 0;
	const unsigned short KANA_KATA = 1;
	const unsigned short KANA_ALL = 2;

	boolean isAlpha(in AString roman);

	AString expand(in AString roman);
	AString expand2(in AString roman, in unsigned short kanaFlag);
};


[scriptable, uuid(159add54-cdf2-11db-8314-0800200c9a66)]
interface pIXMigemoCache : nsISupports
{
	AString getCacheFor(in AString roman);

	/* these two methods saves the file cache automatically. if you don't want to be updated the file, use "clearCacheSilentlyFor". */
	void clearCacheForAllPatterns(in AString roman);
	void clearCacheFor(in AString roman);

	void clearCacheSilentlyFor(in AString roman);

	void clearAll(in boolean clearDiskCache);

	void setMemCache(in AString roman, in AString regExpPattern);
	void setDiskCache(in AString roman, in AString regExpPattern);

	attribute nsIFile cacheFile;

	readonly attribute boolean initialized;

	boolean load();
	void reload();
	void save();
};

[scriptable, uuid(6f19900a-ce33-11db-8314-0800200c9a66)]
interface pIXMigemoDictionary : nsISupports
{
	void saveUserDic(in ACString key);

	AString getDic(in ACString key);
	AString getUserDic(in ACString key);
	AString getAlphaDic();
	AString getUserAlphaDic();
	AString getDicForTerm(in AString yomi);

	const unsigned short RESULT_OK                      = 1;
	const unsigned short RESULT_ERROR_INVALID_YOMI      = 2;
	const unsigned short RESULT_ERROR_ALREADY_EXIST     = 4;
	const unsigned short RESULT_ERROR_NOT_EXIST         = 8;
	const unsigned short RESULT_ERROR_NO_TARGET         = 16;
	const unsigned short RESULT_ERROR_INVALID_OPERATION = 32;

	unsigned short addTerm(in AString yomi, in AString term);
	unsigned short removeTerm(in AString yomi, in AString term);

	readonly attribute boolean initialized;

	boolean load();
	void reload();
	void save();
};

[scriptable, uuid(4ec63ba8-ce38-11db-8314-0800200c9a66)]
interface pIXMigemoDicManager : nsIObserver
{
	void reload();

	AString showDirectoryPicker(in AString defaultDirectoryPath);

	void init();
};



